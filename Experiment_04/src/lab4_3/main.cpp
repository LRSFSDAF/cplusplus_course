#include <iostream>
#include "complex.h"

using namespace std;

int main() {
    // ---------------------------------------------------------
    // 第一部分：测试静态成员与对象计数
    // ---------------------------------------------------------
    cout << "--- 1. 测试对象计数器 ---" << endl;
    cout << "初始数量: " << Complex::number() << endl; // 应为 0

    Complex a(1.0, 2.0);
    cout << "创建对象 a 后数量: " << a.number() << endl; // 应为 1

    Complex b(3.0, 4.0);
    cout << "创建对象 b 后数量: " << Complex::number() << endl; // 应为 2

    {
        // 进入局部作用域
        Complex c = a; // 调用复制构造函数
        cout << "创建局部对象 c 后数量: " << Complex::number() << endl; // 应为 3
    } // c 在这里被销毁，析构函数调用，count--

    cout << "局部对象 c 销毁后数量: " << Complex::number() << endl; // 应变回 2

    
    // ---------------------------------------------------------
    // 第二部分：测试运算符重载
    // ---------------------------------------------------------
    cout << "\n--- 2. 测试运算符重载 ---" << endl;
    cout << "a = " << a << endl;
    cout << "b = " << b << endl;

    // 1. 加法测试
    Complex sum = a + b;
    cout << "a + b = " << sum << endl;

    // 2. 减法测试
    Complex sub = a - b;
    cout << "a - b = " << sub << endl;

    // 3. 乘法测试
    Complex mul = a * b;
    cout << "a * b = " << mul << endl;

    // 4. 【新增】除法测试
    // 理论计算: (1+2i)/(3+4i) = (1+2i)(3-4i)/(9+16) = (3 - 4i + 6i - 8i^2)/25 
    //         = (11 + 2i) / 25 = 0.44 + 0.08i
    Complex div = a / b;
    cout << "a / b = " << div << endl; 
    
    // 5. 赋值测试
    Complex d;
    d = a; 
    cout << "赋值后 d = " << d << endl;
    
    // 6. 比较测试
    if (a == d) cout << "a 和 d 相等" << endl;
    if (a != b) cout << "a 和 b 不相等" << endl;

    return 0;
}

#pragma region tips

/*  
1. 为什么 operator= 必须是成员函数？
这是 C++ 语言标准的强制规定。如果你试图把 operator= 定义为友元函数，编译器直接会报错。
背后的深层原因：
避免与默认版本冲突：
如果你不写赋值运算符，编译器会自动给类生成一个默认的赋值运算符（Default Assignment Operator）。
如果 C++ 允许你在类外面（友元/全局）再写一个 operator=，那么当编译器遇到 a = b 时，它就懵了：“我是该调用我自己生成的那个成员函数呢？还是调用你写的那个全局函数呢？”
为了杜绝这种二义性，C++ 干脆规定：赋值运算符只能是成员函数。
语义逻辑：
赋值是改变对象自身状态的操作。a = b 的意思是“把 a 的内部状态改成和 b 一样”。
这是一个“主观”动作，必须由对象自己（this）来完成，所以作为成员函数最合乎逻辑。


2. 为什么 +, -, == 等建议定义为友元函数？
虽然把它们定义为成员函数也能跑通，但在数学逻辑和使用体验上会有巨大缺陷。
核心理由：为了支持“混合运算”和“交换律”。
让我们看一个具体的例子。假设我们的 Complex 类有一个构造函数 Complex(double r)，它可以把一个小数隐式转换成复数。
场景：复数与小数相加
情况 A：如果 operator+ 是【成员函数】
c1 + 10.0
编译器翻译为：c1.operator+(10.0)。
结果：✅ 成功。因为 operator+ 接收 Complex 类型，编译器会自动把 10.0 变成 Complex(10.0) 然后传进去。
10.0 + c1
编译器翻译为：10.0.operator+(c1)。
结果：❌ 报错！ 因为 10.0 是 double 类型，它是 C++ 的内置类型，你不可能去修改 double 类型的源码给它加一个成员函数。
情况 B：如果 operator+ 是【友元函数】（全局函数）
c1 + 10.0
编译器翻译为：operator+(c1, 10.0)。
结果：✅ 成功。
10.0 + c1
编译器翻译为：operator+(10.0, c1)。
结果：✅ 成功！
原因：友元函数是一个普通函数，它有两个参数。编译器非常聪明，它发现第一个参数需要 Complex 但给的是 double，它会查看有没有构造函数能转换，发现有 Complex(double)，于是它自动把 10.0 变成了临时复数对象，然后再调用函数。

3.<< >> 为什么必须是友元函数？
<< >>	友元函数	必须	因为左操作数是 cout/cin，不是你的类对象。

4. 计数器的实现原理
增加：在每一个能产生新对象的构造函数（包括普通构造和复制构造）中，都执行 m_count++。
减少：在析构函数中执行 m_count--。
不变化：在赋值函数（operator=）中，只是修改已有对象的值，并没有产生新对象，所以不需要修改计数。

5. 静态成员函数的特殊性
静态成员函数（如 number()）：它不属于任何一个具体的对象，它属于整个类。它没有 this 指针，它根本看不到 a 对象内部的私有数据（m_real, m_imag），它只能看到全类共享的 m_count。

*/

#pragma endregion
